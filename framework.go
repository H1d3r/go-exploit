package exploit

import (
	"crypto/tls"
	"math/rand"
	"net/http"
	"time"

	"github.com/vulncheck-oss/go-exploit/c2"
	"github.com/vulncheck-oss/go-exploit/cli"
	"github.com/vulncheck-oss/go-exploit/config"
	"github.com/vulncheck-oss/go-exploit/output"
)

type VersionCheckType int

const (
	NotVulnerable      VersionCheckType = 0
	Vulnerable         VersionCheckType = 1
	PossiblyVulnerable VersionCheckType = 2
	Unknown            VersionCheckType = 3
	NotImplemented     VersionCheckType = 4
)

type Exploit interface {
	ValidateTarget(conf *config.Config) bool
	CheckVersion(conf *config.Config) VersionCheckType
	RunExploit(conf *config.Config) bool
}

func doVerify(sploit Exploit, conf *config.Config) bool {
	output.PrintfStatus("Validating the remote target is a %s installation", conf.Product)
	if !sploit.ValidateTarget(conf) {
		output.PrintfError("The target isn't recognized as %s, quitting", conf.Product)

		return false
	}
	output.PrintSuccess("Target validation succeeded!")

	return true
}

func doVersionCheck(sploit Exploit, conf *config.Config) bool {
	output.PrintStatus("Running a version check on the remote target")
	result := sploit.CheckVersion(conf)
	switch result {
	case NotVulnerable:
		output.PrintError("The target appears to be a patched version. Quitting.")

		return false
	case Vulnerable:
		output.PrintSuccess("The target appears to be a vulnerable version!")
	case PossiblyVulnerable:
		output.PrintStatus("The target *might* be a vulnerable version. Continuing.")
	case Unknown:
		output.PrintError("The result of the version check returned an unknown state. Quitting.")

		return false
	case NotImplemented:
		output.PrintStatus("This exploit has not implemented a version check. Continuing.")
	}

	return true
}

func doExploit(sploit Exploit, conf *config.Config) bool {
	switch conf.ExType {
	case config.CodeExecution:
		if conf.ThirdPartyC2Server {
			// c2 will be handled by a different program
			sploit.RunExploit(conf)
		} else {
			// create the requested C2 server
			c2Impl, ok := c2.GetInstance(conf.C2Type)
			if !ok {
				return false
			}

			// spawn a tcp listener
			if c2Impl == nil {
				return false
			}

			var initSuccess bool
			if conf.Bport != 0 {
				// the c2 is a client
				initSuccess = c2Impl.Init(conf.Rhost, conf.Bport, true)
			} else {
				// the c2 is a reverse shell
				initSuccess = c2Impl.Init(conf.Lhost, conf.Lport, false)
			}

			if !initSuccess {
				return false
			}

			// run exploit in goroutine
			go sploit.RunExploit(conf)

			// listen/connect depending on the c2 impl
			c2Impl.Run(conf.C2Timeout)
		}
	case config.InformationDisclosure:
		fallthrough
	case config.Webshell:
		if !sploit.RunExploit(conf) {
			return false
		}
	}

	return true
}

func RunProgram(sploit Exploit, conf *config.Config) {
	switch conf.ExType {
	case config.CodeExecution:
		if !cli.CodeExecutionCmdLineParse(conf) {
			return
		}
	case config.InformationDisclosure:
		if !cli.InformationDisclosureCmdLineParse(conf) {
			return
		}
	case config.Webshell:
		if !cli.WebShellCmdLineParse(conf) {
			return
		}
	default:
		output.PrintError("Invalid exploit type provided.")

		return
	}

	// in case random is needed
	rand.Seed(time.Now().UnixNano())

	// disable https cert verification globally
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}

	if conf.DoVerify {
		if !doVerify(sploit, conf) {
			return
		}
	}

	if conf.DoVersionCheck {
		if !doVersionCheck(sploit, conf) {
			return
		}
	}

	if conf.DoExploit {
		if !doExploit(sploit, conf) {
			return
		}
	}
}
