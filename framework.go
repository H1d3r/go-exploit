package exploit

import (
	"crypto/tls"
	"math/rand"
	"net"
	"net/http"
	"strconv"
	"sync"
	"time"

	"github.com/vulncheck-oss/go-exploit/c2"
	"github.com/vulncheck-oss/go-exploit/cli"
	"github.com/vulncheck-oss/go-exploit/config"
	"github.com/vulncheck-oss/go-exploit/output"
)

type VersionCheckType int

const (
	NotVulnerable      VersionCheckType = 0
	Vulnerable         VersionCheckType = 1
	PossiblyVulnerable VersionCheckType = 2
	Unknown            VersionCheckType = 3
	NotImplemented     VersionCheckType = 4
)

type Exploit interface {
	ValidateTarget(conf *config.Config) bool
	CheckVersion(conf *config.Config) VersionCheckType
	RunExploit(conf *config.Config) bool
}

var globalWG sync.WaitGroup

func doVerify(sploit Exploit, conf *config.Config) bool {
	output.PrintfStatus("Validating the remote target is a %s installation", conf.Product)
	if !sploit.ValidateTarget(conf) {
		output.PrintfError("The target isn't recognized as %s, quitting", conf.Product)

		return false
	}
	output.PrintSuccess("Target validation succeeded!")

	return true
}

func doVersionCheck(sploit Exploit, conf *config.Config) bool {
	output.PrintStatus("Running a version check on the remote target")
	result := sploit.CheckVersion(conf)
	switch result {
	case NotVulnerable:
		output.PrintError("The target appears to be a patched version. Quitting.")

		return false
	case Vulnerable:
		output.PrintSuccess("The target appears to be a vulnerable version!")
	case PossiblyVulnerable:
		output.PrintStatus("The target *might* be a vulnerable version. Continuing.")
	case Unknown:
		output.PrintError("The result of the version check returned an unknown state. Quitting.")

		return false
	case NotImplemented:
		output.PrintStatus("This exploit has not implemented a version check. Continuing.")
	}

	return true
}

// connects to the remote server and tries to determine if the server expects SSL comms
// this is accomplished by attempting to read 5 bytes from the server and timing out
// if it fails. This is a fair amount of overhead if done at scale, but reasonable for
// someone that is using -a (instead of -s or nothing). This should only be slow on
// non-ssl connections...
func determineServerSSL(rhost string, rport int) bool {
	conf := &tls.Config{
		InsecureSkipVerify: true,
	}

	conn, err := tls.DialWithDialer(&net.Dialer{Timeout: 5 * time.Second}, "tcp", rhost+":"+strconv.Itoa(rport), conf)
	if err != nil {
		return false
	}
	conn.Close()

	return true
}

func parseCommandLine(conf *config.Config) bool {
	switch conf.ExType {
	case config.CodeExecution:
		return cli.CodeExecutionCmdLineParse(conf)
	case config.InformationDisclosure:
		return cli.InformationDisclosureCmdLineParse(conf)
	case config.Webshell:
		return cli.WebShellCmdLineParse(conf)
	default:
		output.PrintError("Invalid exploit type provided.")

		return false
	}
}

func startC2Server(conf *config.Config) {
	if conf.DoExploit && conf.ExType == config.CodeExecution && !conf.ThirdPartyC2Server && conf.Bport == 0 {
		c2Impl, success := c2.GetInstance(conf.C2Type)
		if !success || c2Impl == nil {
			return
		}

		success = c2Impl.Init(conf.Lhost, conf.Lport, false)
		if !success {
			return
		}

		globalWG.Add(1)
		go func() {
			defer globalWG.Done()
			c2Impl.Run(conf.C2Timeout)
			output.PrintStatus("C2 server exited")
		}()
	}
}

// execute verify, version check, and exploit. Return false if an unrecoverable error occurred.
func doScan(sploit Exploit, conf *config.Config) bool {
	// autodetect if the the target is using SSL or not
	if conf.DetermineSSL {
		conf.SSL = determineServerSSL(conf.Rhost, conf.Rport)
	}

	if conf.DoVerify {
		if !doVerify(sploit, conf) {
			return true
		}
	}

	if conf.DoVersionCheck {
		if !doVersionCheck(sploit, conf) {
			return true
		}
	}

	if conf.DoExploit {
		// execute exploit attempts on a new thread
		globalWG.Add(1)
		go func() {
			defer globalWG.Done()
			ok := sploit.RunExploit(conf)
			if ok {
				output.PrintStatus("Exploit successfully completed")
			} else {
				output.PrintStatus("Exploit exited with an error")
			}
		}()

		// if the "c2" connects to a bindshell, call init to update the rhost/bport
		// and then attempt to connect
		if !conf.ThirdPartyC2Server && conf.Bport != 0 {
			c2Impl, success := c2.GetInstance(conf.C2Type)
			if !success || c2Impl == nil {
				return false
			}

			success = c2Impl.Init(conf.Rhost, conf.Bport, true)
			if !success {
				return false
			}

			globalWG.Add(1)
			go func() {
				defer globalWG.Done()
				c2Impl.Run(conf.C2Timeout)
				output.PrintStatus("C2 client exited")
			}()
		}
	}

	return true
}

func RunProgram(sploit Exploit, conf *config.Config) {
	if !parseCommandLine(conf) {
		return
	}

	// in case random is needed
	rand.Seed(time.Now().UnixNano())

	// disable https cert verification globally
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}

	// if the c2 server catches responses, initialize and start so it can bind
	startC2Server(conf)

	// loop over all the provided host / port combos
	for hindex, host := range conf.Rhosts {
		conf.Rhost = host
		for pindex, port := range conf.Rports {
			conf.Rport = port
			output.PrintfStatus("Starting target %d: %s:%d", hindex+pindex, conf.Rhost, conf.Rport)

			if !doScan(sploit, conf) {
				return
			}
			globalWG.Wait()
		}
	}
}
