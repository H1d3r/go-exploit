package cli

import (
	"flag"
	"fmt"
	"strconv"
	"strings"

	"github.com/vulncheck-oss/go-exploit/c2"
	"github.com/vulncheck-oss/go-exploit/config"
	"github.com/vulncheck-oss/go-exploit/output"
)

func commonValidate(conf *config.Config, rhosts string, rports string) bool {
	valid := true

	switch {
	case len(conf.Rhost) == 0 && len(rhosts) == 0:
		valid = false
		output.PrintError("Missing required option 'rhost' or 'rhosts'")
	case conf.Rport == 0 && len(rports) == 0:
		valid = false
		output.PrintError("Missing required option 'rport' or 'rports'")
	case !conf.DoVerify && !conf.DoVersionCheck && !conf.DoExploit:
		valid = false
		output.PrintError("Please provide an action (-v, -c, -e)")
	case conf.SSL && conf.DetermineSSL:
		valid = false
		output.PrintError("-a and -s are mutually exclusive")
	}

	// convert the provided Rports to a slice of int
	if len(rports) != 0 {
		splitPorts := strings.Split(rports, ",")
		for _, port := range splitPorts {
			portInt, err := strconv.Atoi(port)
			if err != nil {
				output.PrintfError("Failed to convert provided rports: %s", err)

				return false
			}
			fmt.Println(portInt)
			conf.Rports = append(conf.Rports, portInt)
		}
	} else {
		conf.Rports = append(conf.Rports, conf.Rport)
	}

	if len(rhosts) != 0 {
		splitRhosts := strings.Split(rhosts, ",")
		conf.Rhosts = append(conf.Rhosts, splitRhosts...)
	} else {
		conf.Rhosts = append(conf.Rhosts, conf.Rhost)
	}

	return valid
}

// command line flags for defining the remote host.
func remoteHostFlags(conf *config.Config, rhosts *string, rports *string) {
	flag.StringVar(&conf.Rhost, "rhost", "", "The remote target's IP address")
	flag.StringVar(rhosts, "rhosts", "", "A comma delimited list of remote target IP addresses")
	// the Rport should be pre-configured to have a default value (see config.go:New())
	flag.IntVar(&conf.Rport, "rport", conf.Rport, "The remote target's server port")
	flag.StringVar(rports, "rports", "", "A comma delimited list of the remote target's server ports")
}

// command line flags for defining the local host.
func localHostFlags(conf *config.Config) {
	flag.StringVar(&conf.Lhost, "lhost", "", "The IP address the configured c2 will bind to")
	flag.IntVar(&conf.Lport, "lport", 0, "The port the configured c2 will bind to")
}

// command line flags that control the exploits behavior.
func exploitFunctionality(conf *config.Config) {
	flag.BoolVar(&conf.DoVerify, "v", false, "Verify the target is "+conf.Product)
	flag.BoolVar(&conf.DoVersionCheck, "c", false, "Perform a version check before attempting exploitation")
	flag.BoolVar(&conf.DoExploit, "e", false, "Exploit the target")
}

// command line flags that control ssl communication with the target.
func sslFlags(conf *config.Config) {
	flag.BoolVar(&conf.SSL, "s", false, "Use https to communicate with the target")
	flag.BoolVar(&conf.DetermineSSL, "a", false, "Automatically determine if the remote target uses SSL")
}

// Parses the command line arguments used by RCE exploits.
func CodeExecutionCmdLineParse(conf *config.Config) bool {
	var rhosts string
	var rports string

	remoteHostFlags(conf, &rhosts, &rports)
	localHostFlags(conf)
	exploitFunctionality(conf)
	sslFlags(conf)

	// flags unique to remote code execution
	flag.IntVar(&conf.Bport, "bport", 0, "The port to attach the bind shell to")
	flag.IntVar(&conf.C2Timeout, "t", 30, "The number of seconds to listen for reverse shells.")
	flag.BoolVar(&conf.ThirdPartyC2Server, "o", false, "Indicates if the reverse shell should be caught by an outside program (nc, openssl)")

	// c2 selection. defaults to the implementations first supported value
	var c2Selection string
	c2Default, _ := c2.ImplToString(conf.SupportedC2[0])
	c2Available := "The C2 server implementation to use. Supported: "
	for _, value := range conf.SupportedC2 {
		c2Name, ok := c2.ImplToString(value)
		if ok {
			c2Available += "\n\t" + c2Name
		}

		// add the supported c2 flags, allowing for command line config of the backend
		impl, success := c2.GetInstance(value)
		if success {
			impl.CreateFlags()
		}
	}
	c2Available += "\n"
	flag.StringVar(&c2Selection, "c2", c2Default, c2Available)

	flag.Usage = func() {
		// banner explaining what the software is
		fmt.Printf("An exploit for %s %s that can generate a reverse shell or bind shell\n\n", conf.Product, conf.CVE)

		// print default usage information
		flag.PrintDefaults()
	}
	flag.Parse()

	// validate command line arguments
	success := commonValidate(conf, rhosts, rports)

	// validate a reverse shell or bind shell params are correctly specified
	if conf.DoExploit {
		c2Selected, ok := c2.StringToImpl(c2Selection)
		if !ok {
			output.PrintError("Provided an invalid c2 implementation")
			success = false
		}
		// is this a supported c2?
		foundSupported := false
		for _, value := range conf.SupportedC2 {
			if c2Selected == value {
				foundSupported = true
			}
		}
		if !foundSupported {
			output.PrintError("The c2 you selected is not supported by this exploit.")
			success = false
		}
		conf.C2Type = c2Selected

		if conf.Bport == 0 && (conf.Lport == 0 || len(conf.Lhost) == 0) {
			output.PrintError("Missing exploitation options (bindshell or reverse shell)")
			success = false
		}
		if conf.Bport != 0 && conf.Lport != 0 {
			output.PrintError("User specified both bind shell and reverse shell ports")
			success = false
		}
	}

	return success
}

func InformationDisclosureCmdLineParse(conf *config.Config) bool {
	var rhosts string
	var rports string

	remoteHostFlags(conf, &rhosts, &rports)
	localHostFlags(conf)
	exploitFunctionality(conf)
	sslFlags(conf)

	flag.Usage = func() {
		// banner explaining what the software is
		fmt.Printf("An exploit for %s %s that can leak sensitive data\n\n", conf.Product, conf.CVE)

		// print default usage information
		flag.PrintDefaults()

		// usage examples
		fmt.Println("Usage example:")
		fmt.Println("\t./exploit -v -c -e -a -rhost 10.12.70.247 -rport 443")
	}
	flag.Parse()

	// validate command line arguments
	return commonValidate(conf, rhosts, rports)
}

func WebShellCmdLineParse(conf *config.Config) bool {
	var rhosts string
	var rports string

	remoteHostFlags(conf, &rhosts, &rports)
	localHostFlags(conf)
	exploitFunctionality(conf)
	sslFlags(conf)

	flag.Usage = func() {
		// banner explaining what the software is
		fmt.Printf("An exploit for %s %s that drops a webshell\n\n", conf.Product, conf.CVE)

		// print default usage information
		flag.PrintDefaults()

		// usage examples
		fmt.Println("Usage example:")
		fmt.Println("\t./exploit -v -c -e -a -rhost 10.12.70.247 -rport 443")
	}
	flag.Parse()

	// validate command line arguments
	return commonValidate(conf, rhosts, rports)
}
