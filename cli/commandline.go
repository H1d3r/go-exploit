package cli

import (
	"crypto/tls"
	"flag"
	"fmt"
	"net"
	"strconv"
	"time"

	"github.com/vulncheck-oss/go-exploit/c2"
	"github.com/vulncheck-oss/go-exploit/config"
	"github.com/vulncheck-oss/go-exploit/output"
)

func commonValidate(conf *config.Config, determineSSL bool) bool {
	valid := true

	switch {
	case len(conf.Rhost) == 0:
		valid = false
		output.PrintError("Missing required option 'rhost'")
	case conf.Rport == 0:
		valid = false
		output.PrintError("Missing required option 'rport'")
	case !conf.DoVerify && !conf.DoVersionCheck && !conf.DoExploit:
		valid = false
		output.PrintError("Please provide an action (-v, -c, -e)")
	case conf.SSL && determineSSL:
		valid = false
		output.PrintError("-a and -s are mutually exclusive")
	}

	return valid
}

// connects to the remote server and tries to determine if the server expects SSL comms
// this is accomplished by attempting to read 5 bytes from the server and timing out
// if it fails. This is a fair amount of overhead if done at scale, but reasonable for
// someone that is using -a (instead of -s or nothing). This should only be slow on
// non-ssl connections...
func determineServerSSL(rhost string, rport int) bool {
	conf := &tls.Config{
		InsecureSkipVerify: true,
	}

	conn, err := tls.DialWithDialer(&net.Dialer{Timeout: 4 * time.Second}, "tcp", rhost+":"+strconv.Itoa(rport), conf)
	if err != nil {
		return false
	}
	conn.Close()

	return true
}

// command line flags for defining the remote host.
func remoteHostFlags(conf *config.Config) {
	flag.StringVar(&conf.Rhost, "rhost", "", "The remote target's IP address")
	// the Rport should be pre-configured to have a default value (see config.go:New())
	flag.IntVar(&conf.Rport, "rport", conf.Rport, "The remote target's server port")
}

// command line flags for defining the local host.
func localHostFlags(conf *config.Config) {
	flag.StringVar(&conf.Lhost, "lhost", "", "The IP address to send the reverse shell or infoleak to")
	flag.IntVar(&conf.Lport, "lport", 0, "The port to send the reverse shell or infoleak to")
}

// command line flags that control the exploits behavior.
func exploitFunctionality(conf *config.Config) {
	flag.BoolVar(&conf.DoVerify, "v", false, "Verify the target is "+conf.Product)
	flag.BoolVar(&conf.DoVersionCheck, "c", false, "Perform a version check before attempting exploitation")
	flag.BoolVar(&conf.DoExploit, "e", false, "Exploit the target")
}

// command line flags that control ssl communication with the target.
func sslFlags(conf *config.Config, determineSSL *bool) {
	flag.BoolVar(&conf.SSL, "s", false, "Use https to communicate with the target")
	flag.BoolVar(determineSSL, "a", false, "Automatically determine if the remote target uses SSL")
}

// Parses the command line arguments used by RCE exploits.
func CodeExecutionCmdLineParse(conf *config.Config) bool {
	var determineSSL bool

	remoteHostFlags(conf)
	localHostFlags(conf)
	exploitFunctionality(conf)
	sslFlags(conf, &determineSSL)

	// flags unique to remote code execution
	flag.IntVar(&conf.Bport, "bport", 0, "The port to attach the bind shell to")
	flag.IntVar(&conf.C2Timeout, "t", 30, "The number of seconds to listen for reverse shells.")
	flag.BoolVar(&conf.ThirdPartyC2Server, "o", false, "Indicates if the reverse shell should be caught by an outside program (nc, openssl)")

	// c2 selection. defaults to the implementations first supported value
	var c2Selection string
	c2Default, _ := c2.ImplToString(conf.SupportedC2[0])
	c2Available := "The C2 server implementation to use. Supported: "
	for _, value := range conf.SupportedC2 {
		c2Name, ok := c2.ImplToString(value)
		if ok {
			c2Available += "\n\t" + c2Name
		}
	}
	c2Available += "\n"
	flag.StringVar(&c2Selection, "c2", c2Default, c2Available)

	flag.Usage = func() {
		// banner explaining what the software is
		fmt.Printf("An exploit for %s %s that can generate a reverse shell or bind shell\n\n", conf.Product, conf.CVE)

		// print default usage information
		flag.PrintDefaults()
	}
	flag.Parse()

	// validate command line arguments
	success := commonValidate(conf, determineSSL)

	// validate a reverse shell or bind shell params are correctly specified
	if conf.DoExploit {
		c2Selected, ok := c2.StringToImpl(c2Selection)
		if !ok {
			output.PrintError("Provided an invalid c2 implementation")
			success = false
		}
		// is this a supported c2?
		foundSupported := false
		for _, value := range conf.SupportedC2 {
			if c2Selected == value {
				foundSupported = true
			}
		}
		if !foundSupported {
			output.PrintError("The c2 you selected is not supported by this exploit.")
			success = false
		}
		conf.C2Type = c2Selected

		if conf.Bport == 0 && (conf.Lport == 0 || len(conf.Lhost) == 0) {
			output.PrintError("Missing exploitation options (bindshell or reverse shell)")
			success = false
		}
		if conf.Bport != 0 && conf.Lport != 0 {
			output.PrintError("User specified both bind shell and reverse shell ports")
			success = false
		}
	}

	if success && determineSSL {
		conf.SSL = determineServerSSL(conf.Rhost, conf.Rport)
	}

	return success
}

func InformationDisclosureCmdLineParse(conf *config.Config) bool {
	var determineSSL bool

	remoteHostFlags(conf)
	localHostFlags(conf)
	exploitFunctionality(conf)
	sslFlags(conf, &determineSSL)

	flag.Usage = func() {
		// banner explaining what the software is
		fmt.Printf("An exploit for %s %s that can leak sensitive data\n\n", conf.Product, conf.CVE)

		// print default usage information
		flag.PrintDefaults()

		// usage examples
		fmt.Println("Usage example:")
		fmt.Println("\t./exploit -v -c -e -a -rhost 10.12.70.247 -rport 443")
	}
	flag.Parse()

	// validate command line arguments
	ok := commonValidate(conf, determineSSL)
	if ok && determineSSL {
		conf.SSL = determineServerSSL(conf.Rhost, conf.Rport)
	}

	return ok
}

func WebShellCmdLineParse(conf *config.Config) bool {
	var determineSSL bool

	remoteHostFlags(conf)
	localHostFlags(conf)
	exploitFunctionality(conf)
	sslFlags(conf, &determineSSL)

	flag.Usage = func() {
		// banner explaining what the software is
		fmt.Printf("An exploit for %s %s that drops a webshell\n\n", conf.Product, conf.CVE)

		// print default usage information
		flag.PrintDefaults()

		// usage examples
		fmt.Println("Usage example:")
		fmt.Println("\t./exploit -v -c -e -a -rhost 10.12.70.247 -rport 443")
	}
	flag.Parse()

	// validate command line arguments
	ok := commonValidate(conf, determineSSL)
	if ok && determineSSL {
		conf.SSL = determineServerSSL(conf.Rhost, conf.Rport)
	}

	return ok
}
