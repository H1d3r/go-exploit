package httpservefile

import (
	"flag"
	"fmt"
	"net/http"
	"os"
	"path"
	"time"

	"github.com/vulncheck-oss/go-exploit/output"
	"github.com/vulncheck-oss/go-exploit/random"
)

// The httpservefile Server spawns an HTTP server and hosts a single user provided file. The normal use case
// is for an exploit to curl/wget the file and execute it. This is useful to spawn connections to other
// tools (e.g. Metasploit, nc, etc.). This is not a traditional "c2" but serves as a useful backend that
// logically plugs into our c2 design.
type Server struct {
	// The local filename to read in
	FileToServe string
	// A randomly generated filename to serve
	FileName string
	// The file data to send to the client
	FileData []byte
	// The HTTP address to bind to
	HTTPAddr string
	// The HTTP port to bind to
	HTTPPort int
	// Set to the Server field in HTTP response
	ServerField string
}

var singleton *Server

// A basic singleton interface for the c2.
func GetInstance() *Server {
	if singleton == nil {
		singleton = new(Server)
	}

	return singleton
}

// User options for serving a file over HTTP as the "c2".
func (httpServer *Server) CreateFlags() {
	flag.StringVar(&httpServer.FileToServe, "httpServeFile.FileToServe", "", "The file to serve on the HTTP server")
	flag.StringVar(&httpServer.ServerField, "httpServeFile.ServerField", "Apache", "The value to insert in the HTTP server field")
}

// load the provided file into memory. Generate the random filename.
func (httpServer *Server) Init(rhostAddr string, rhostPort int, isClient bool) bool {
	if isClient {
		output.PrintFrameworkError("Called C2HTTPServer as a client. Use lhost and lport.")

		return false
	}
	httpServer.HTTPAddr = rhostAddr
	httpServer.HTTPPort = rhostPort

	if len(httpServer.FileToServe) == 0 {
		output.PrintFrameworkError("Provide an httpServeFile.FileToServe option on the command line")

		return false
	}

	output.PrintfFrameworkStatus("Loading the provided file: %s", httpServer.FileToServe)
	var err error
	httpServer.FileData, err = os.ReadFile(httpServer.FileToServe)
	if err != nil {
		output.PrintFrameworkError(err.Error())

		return false
	}

	// the server will only respond 200 if this filename is requested
	httpServer.FileName = random.RandLetters(12)

	return true
}

// start the HTTP server and listen for incoming requests for `httpServer.FileName`.
func (httpServer *Server) Run(timeout int) {
	// validate the request is for the appropriate file and then send it
	http.HandleFunc("/"+httpServer.FileName, func(writer http.ResponseWriter, r *http.Request) {
		// set the user provided HTTP server field
		writer.Header().Set("Server", httpServer.ServerField)
		if path.Base(r.URL.Path) == httpServer.FileName {
			// respond with the binary
			writer.Header().Set("Content-Type", "application/octet-stream")
			_, _ = writer.Write(httpServer.FileData)
		}
	})

	connectionString := fmt.Sprintf("%s:%d", httpServer.HTTPAddr, httpServer.HTTPPort)
	output.PrintfFrameworkStatus("Starting an HTTP Server on %s", connectionString)
	go func() {
		_ = http.ListenAndServe(connectionString, nil)
	}()

	// let the server run for timeout seconds
	time.Sleep(time.Duration(timeout) * time.Second)

	// We don't actually clean up anything, but exiting c2 will eventually terminate the program
	output.PrintFrameworkStatus("Shutting down the HTTP Server")
}
