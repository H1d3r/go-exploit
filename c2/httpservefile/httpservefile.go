// httpservefile c2 spawns an HTTP or HTTPS server and hosts a single user provided file. The normal use case
// is for an exploit to curl/wget the file and execute it. This is useful to spawn connections to other
// tools (e.g. Metasploit, nc, etc.). This is not a traditional "c2" but serves as a useful backend that
// logically plugs into our c2 design.
package httpservefile

import (
	"crypto/tls"
	"flag"
	"fmt"
	"net/http"
	"os"
	"path"
	"time"

	"github.com/vulncheck-oss/go-exploit/encryption"
	"github.com/vulncheck-oss/go-exploit/output"
	"github.com/vulncheck-oss/go-exploit/random"
)

type Server struct {
	// The local filename to read in
	FileToServe string
	// A randomly generated filename to serve
	FileName string
	// The file data to send to the client
	FileData []byte
	// The HTTP address to bind to
	HTTPAddr string
	// The HTTP port to bind to
	HTTPPort int
	// Set to the Server field in HTTP response
	ServerField string
	// Indicates if TLS should be enabled
	TLS bool
	// The file path to the user provided private key (if provided)
	PrivateKeyFile string
	// The file path to the user provided certificate (if provided)
	CertificateFile string
}

var singleton *Server

// A basic singleton interface for the c2.
func GetInstance() *Server {
	if singleton == nil {
		singleton = new(Server)
	}

	return singleton
}

// User options for serving a file over HTTP as the "c2".
func (httpServer *Server) CreateFlags() {
	flag.StringVar(&httpServer.FileToServe, "httpServeFile.FileToServe", "", "The file to serve on the HTTP server")
	flag.StringVar(&httpServer.ServerField, "httpServeFile.ServerField", "Apache", "The value to insert in the HTTP server field")
	flag.BoolVar(&httpServer.TLS, "httpServeFile.TLS", false, "Indicates if the HTTP server should use encryption")
	flag.StringVar(&httpServer.PrivateKeyFile, "httpServer.PrivateKeyFile", "", "A private key to use with the HTTPS server")
	flag.StringVar(&httpServer.CertificateFile, "httpServer.CertificateFile", "", "The certificate to use with the HTTPS server")
}

// load the provided file into memory. Generate the random filename.
func (httpServer *Server) Init(rhostAddr string, rhostPort int, isClient bool) bool {
	if isClient {
		output.PrintFrameworkError("Called C2HTTPServer as a client. Use lhost and lport.")

		return false
	}
	httpServer.HTTPAddr = rhostAddr
	httpServer.HTTPPort = rhostPort

	if len(httpServer.FileToServe) == 0 {
		output.PrintFrameworkError("Provide an httpServeFile.FileToServe option on the command line")

		return false
	}

	output.PrintfFrameworkStatus("Loading the provided file: %s", httpServer.FileToServe)
	var err error
	httpServer.FileData, err = os.ReadFile(httpServer.FileToServe)
	if err != nil {
		output.PrintFrameworkError(err.Error())

		return false
	}

	// the server will only respond 200 if this filename is requested
	httpServer.FileName = random.RandLetters(12)

	return true
}

// start the HTTP server and listen for incoming requests for `httpServer.FileName`.
func (httpServer *Server) Run(timeout int) {
	// validate the request is for the appropriate file and then send it
	http.HandleFunc("/"+httpServer.FileName, func(writer http.ResponseWriter, r *http.Request) {
		// set the user provided HTTP server field
		writer.Header().Set("Server", httpServer.ServerField)
		if path.Base(r.URL.Path) == httpServer.FileName {
			// respond with the binary
			writer.Header().Set("Content-Type", "application/octet-stream")
			_, _ = writer.Write(httpServer.FileData)
		}
	})

	var certificate tls.Certificate
	if httpServer.TLS {
		var ok bool
		var err error
		if len(httpServer.CertificateFile) != 0 && len(httpServer.PrivateKeyFile) != 0 {
			certificate, err = tls.LoadX509KeyPair(httpServer.CertificateFile, httpServer.PrivateKeyFile)
			if err != nil {
				output.PrintfFrameworkError("Error loading certificate: %s", err.Error())

				return
			}
		} else {
			output.PrintFrameworkStatus("Certificate not provided. Generating a TLS Certificate")
			certificate, ok = encryption.GenerateCertificate()
			if !ok {
				return
			}
		}
	}

	connectionString := fmt.Sprintf("%s:%d", httpServer.HTTPAddr, httpServer.HTTPPort)
	go func() {
		if httpServer.TLS {
			output.PrintfFrameworkStatus("Starting an HTTPS server on %s", connectionString)
			tlsConfig := &tls.Config{
				Certificates: []tls.Certificate{certificate},
				// We have no control over the SSL versions supported on the remote target. Be permissive for more targets.
				MinVersion: tls.VersionSSL30,
			}
			server := http.Server{
				Addr:      connectionString,
				TLSConfig: tlsConfig,
			}
			defer server.Close()
			_ = server.ListenAndServeTLS("", "")
		} else {
			output.PrintfFrameworkStatus("Starting an HTTP server on %s", connectionString)
			_ = http.ListenAndServe(connectionString, nil)
		}
	}()

	// let the server run for timeout seconds
	time.Sleep(time.Duration(timeout) * time.Second)

	// We don't actually clean up anything, but exiting c2 will eventually terminate the program
	output.PrintFrameworkStatus("Shutting down the HTTP Server")
}
