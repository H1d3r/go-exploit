package protocol

import (
	"crypto/tls"
	"fmt"
	"net"

	"github.com/vulncheck-oss/go-exploit/output"
)

// Connections to the remote target with or without encryption depending on the ssl bool.
func MixedConnect(host string, port int, ssl bool) (net.Conn, bool) {
	if ssl {
		return TLSConnect(host, port)
	}

	return TCPConnect(host, port)
}

// Connects to the remote target with encryption.
func TLSConnect(host string, port int) (net.Conn, bool) {
	conn, ok := TCPConnect(host, port)
	if !ok {
		return nil, false
	}

	return tls.Client(conn, &tls.Config{InsecureSkipVerify: true}), true
}

// Connects to a remote target without encryption.
func TCPConnect(host string, port int) (net.Conn, bool) {
	target := fmt.Sprintf("%s:%d", host, port)
	tcpAddr, err := net.ResolveTCPAddr("tcp", target)
	if err != nil {
		output.PrintFrameworkError("ResolveTCPAddr failed: " + err.Error())

		return nil, false
	}

	conn, err := net.DialTCP("tcp", nil, tcpAddr)
	if err != nil {
		output.PrintFrameworkError("Connection failed: " + err.Error())

		return nil, false
	}

	return conn, true
}

func TCPWrite(conn net.Conn, data []byte) bool {
	written, err := conn.Write(data)
	if err != nil {
		output.PrintFrameworkError("Server write failed: " + err.Error())

		return false
	}
	if written != len(data) {
		output.PrintFrameworkError("Failed to write all data")

		return false
	}

	return true
}

func TCPReadAmount(conn net.Conn, amount int) ([]byte, bool) {
	reply := make([]byte, amount)
	totalRead := 0

	// keep reading until we hit the desired amount (or an error occurs)
	for totalRead < amount {
		count, err := conn.Read(reply[totalRead:])
		if err != nil {
			output.PrintFrameworkError("Failed to read from the socket: " + err.Error())

			return nil, false
		}
		if count == 0 {
			output.PrintFrameworkError("Connection closed.")

			return nil, false
		}
		totalRead += count
	}

	return reply, true
}
