package protocol

import (
	"encoding/binary"
	"net"

	"github.com/vulncheck-oss/go-exploit/output"
)

type M2Message struct {
	Bools    map[uint32]bool
	U32s     map[uint32]uint32
	Strings  map[uint32][]byte
	Raw      map[uint32][]byte
	ArrayU32 map[uint32][]uint32
	ArrayM2  map[uint32][]*M2Message
}

func NewM2Message() *M2Message {
	var m2 M2Message
	m2.Bools = make(map[uint32]bool)
	m2.U32s = make(map[uint32]uint32)
	m2.Strings = make(map[uint32][]byte)
	m2.Raw = make(map[uint32][]byte)
	m2.ArrayU32 = make(map[uint32][]uint32)
	m2.ArrayM2 = make(map[uint32][]*M2Message)
	return &m2
}

const (
	type_boolean       uint32 = 0
	type_short_length  uint32 = 0x01000000
	type_uint32        uint32 = 0x08000000
	type_string        uint32 = 0x20000000
	type_raw           uint32 = 0x30000000
	type_uint32_array  uint32 = 0x88000000
	type_message_array uint32 = 0xa8000000
)

const (
	var_sys_to         uint32 = 0x00ff0001
	var_from           uint32 = 0x00ff0002
	var_reply_expected uint32 = 0x00ff0005
	var_request_id     uint32 = 0x00ff0006
	var_command        uint32 = 0x00ff0007
	var_error_code     uint32 = 0x00ff0008
	var_error_string   uint32 = 0x00ff0009
	var_session_id     uint32 = 0x00fe0001
)

func (msg M2Message) SetTo(to uint32, handler uint32) {
	uint32_slice := make([]uint32, 2)
	uint32_slice[0] = to
	uint32_slice[1] = handler
	msg.AddU32Array(var_sys_to, uint32_slice)
}

func (msg M2Message) SetCommand(command uint32) {
	msg.AddU32(var_command, command)
}

func (msg M2Message) SetRequestID(id uint32) {
	msg.AddU32(var_request_id, id)
}

func (msg M2Message) SetReplyExpected(expected bool) {
	msg.AddBool(var_reply_expected, expected)
}

func (msg M2Message) SetSessionID(id uint32) {
	msg.AddU32(var_session_id, id)
}

func (msg M2Message) GetSessionID() uint32 {
	return msg.U32s[var_session_id]
}

func (msg M2Message) AddBool(varname uint32, data bool) {
	msg.Bools[varname] = data
}

func (msg M2Message) AddU32(varname uint32, data uint32) {
	msg.U32s[varname] = data
}

func (msg M2Message) AddString(varname uint32, data []byte) {
	msg.Strings[varname] = make([]byte, len(data))
	copy(msg.Strings[varname], data)
}

func (msg M2Message) AddU32Array(varname uint32, data []uint32) {
	msg.ArrayU32[varname] = append(msg.ArrayU32[varname], data...)
}

func (msg M2Message) Serialize() []byte {
	serialized := []byte{}

	for varname, value := range msg.Bools {
		binary_bool := make([]byte, 4)
		if value {
			varname |= type_short_length
		}
		binary.LittleEndian.PutUint32(binary_bool, varname)
		serialized = append(serialized, binary_bool...)
	}

	for varname, value := range msg.U32s {
		varname |= type_uint32
		binary_uint32 := make([]byte, 4)

		if value > 255 {
			binary.LittleEndian.PutUint32(binary_uint32, varname)
			serialized = append(serialized, binary_uint32...)
			binary.LittleEndian.PutUint32(binary_uint32, value)
			serialized = append(serialized, binary_uint32...)
		} else {
			varname |= type_short_length
			binary.LittleEndian.PutUint32(binary_uint32, varname)
			serialized = append(serialized, binary_uint32...)
			serialized = append(serialized, byte(value&0x000000ff))
		}
	}

	for varname, value := range msg.Strings {
		varname |= type_string
		binary_string := make([]byte, 4)

		if len(value) > 255 {
			binary.LittleEndian.PutUint32(binary_string, varname)
			serialized = append(serialized, binary_string...)
			binary_length := make([]byte, 2)
			binary.LittleEndian.PutUint16(binary_length, uint16(len(value)))
			serialized = append(serialized, binary_length...)
		} else {
			varname |= type_short_length
			binary.LittleEndian.PutUint32(binary_string, varname)
			serialized = append(serialized, binary_string...)
			serialized = append(serialized, byte(len(value)))
		}
		serialized = append(serialized, value...)
	}

	for varname, value := range msg.Raw {
		varname |= type_raw
		binary_string := make([]byte, 4)

		if len(value) > 255 {
			binary.LittleEndian.PutUint32(binary_string, varname)
			serialized = append(serialized, binary_string...)
			binary_length := make([]byte, 2)
			binary.LittleEndian.PutUint16(binary_length, uint16(len(value)))
			serialized = append(serialized, binary_length...)
		} else {
			varname |= type_short_length
			binary.LittleEndian.PutUint32(binary_string, varname)
			serialized = append(serialized, binary_string...)
			serialized = append(serialized, byte(len(value)))
		}
		serialized = append(serialized, value...)
	}

	for varname, value := range msg.ArrayU32 {
		varname |= type_uint32_array
		binary_array := make([]byte, 4)
		binary.LittleEndian.PutUint32(binary_array, varname)
		serialized = append(serialized, binary_array...)

		binary_length := make([]byte, 2)
		binary.LittleEndian.PutUint16(binary_length, uint16(len(value)))
		serialized = append(serialized, binary_length...)

		for _, entry := range value {
			binary_entry := make([]byte, 4)
			binary.LittleEndian.PutUint32(binary_entry, entry)
			serialized = append(serialized, binary_entry...)
		}
	}

	// TODO skipping array of m2. I'm not sure I ever used this before
	// and doing it correctly takes some thought

	return serialized
}

func handleStringorRaw(varTypeName uint32, varName uint32, data *[]byte, storage *map[uint32][]byte) bool {
	if len(*data) <= 2 {
		return false
	}
	length := int(binary.LittleEndian.Uint16(*data))
	if (varTypeName & type_short_length) != 0 {
		length = int((*data)[0])
		*data = (*data)[1:]
	} else {
		*data = (*data)[2:]
	}
	if len(*data) < length {
		return false
	}

	(*storage)[varName] = make([]byte, length)
	copy((*storage)[varName], *data)
	*data = (*data)[length:]
	return true
}

// this switch is cursed. it needs to be broke into manageable functions.
func ParseM2Message(data []byte, msg *M2Message) bool {
	if len(data) < 4 {
		return false
	}

	if data[2] == 'M' && data[3] == '2' {
		// the message was passed in with the length + M2 header. Truncate
		// and skip
		m2length := int(data[0])
		data = data[4:]
		data = data[:m2length]
	}

	for len(data) > 4 {
		varTypeName := binary.LittleEndian.Uint32(data)
		varType := varTypeName & 0xf8000000
		varName := varTypeName & 0x00ffffff
		data = data[4:]

		switch varType {
		case type_boolean:
			msg.Bools[varName] = (varTypeName & type_short_length) != 0
		case type_uint32:
			if (varTypeName & type_short_length) != 0 {
				if len(data) == 0 {
					return false
				}
				msg.U32s[varName] = uint32(data[0])
				data = data[1:]
			} else {
				if len(data) < 4 {
					return false
				}
				msg.U32s[varName] = binary.LittleEndian.Uint32(data)
				data = data[4:]
			}
		case type_string:
			ok := handleStringorRaw(varTypeName, varName, &data, &msg.Strings)
			if !ok {
				return false
			}
		case type_raw:
			ok := handleStringorRaw(varTypeName, varName, &data, &msg.Raw)
			if !ok {
				return false
			}
		case type_uint32_array:
			if len(data) <= 2 {
				return false
			}
			array_entries := int(binary.LittleEndian.Uint16(data))
			data = data[2:]
			if len(data) < (array_entries * 4) {
				return false
			}

			for i := 0; i < array_entries; i++ {
				msg.ArrayU32[varName] = append(msg.ArrayU32[varName], binary.LittleEndian.Uint32(data))
				data = data[4:]
			}
		case type_message_array:
			if len(data) <= 2 {
				return false
			}
			length := int(binary.LittleEndian.Uint16(data))
			if (varTypeName & type_short_length) != 0 {
				length = int(data[0])
				data = data[1:]
			} else {
				data = data[2:]
			}
			subdata := make([]byte, length)
			copy(subdata, data)
			subMsg := NewM2Message()
			msg.ArrayM2[varName] = append(msg.ArrayM2[varName], subMsg)

			// recursion... technically not safe. Not checking the return here either is
			// a bold choice. Mostly avoiding handling empty entries.
			_ = ParseM2Message(subdata, subMsg)

			data = data[length:]
		default:
			output.PrintfError("Unhandled %x named %x\n", varType, varName)
		}
	}

	return true
}

func SendM2(conn *net.TCPConn, msg *M2Message) bool {
	output := []byte("M2")
	output = append(output, (msg.Serialize())...)

	outputSize := make([]byte, 2)
	binary.BigEndian.PutUint16(outputSize, uint16(len(output)))
	output = append(outputSize, output...)

	// TODO doesn't work for >0xff
	msgheader := make([]byte, 2)
	msgheader[0] = byte(len(output))
	msgheader[1] = 1
	output = append(msgheader, output...)
	return TCPWrite(conn, output)
}

func ReceiveM2(conn *net.TCPConn, msg *M2Message) bool {
	msgSize, ok := TCPReadAmount(conn, 4)
	if !ok {
		return false
	}

	msgSize = msgSize[2:]
	readSize := int(binary.BigEndian.Uint16(msgSize))
	if readSize == 0 {
		output.PrintfError("The server provided an invalid message length")
		return false
	}

	finalBuffer := []byte{}
	loop := 0

	for readSize > 0xff {
		step := 0xff
		if loop == 0 {
			step -= 2
		}

		msgBytes, ok := TCPReadAmount(conn, step)
		if !ok {
			return false
		}

		loop++
		readSize -= step
		finalBuffer = append(finalBuffer, msgBytes...)

		// this should be two bytes of padding
		msgBytes, ok = TCPReadAmount(conn, 2)
		if !ok {
			return false
		}

		if msgBytes[1] != 0xff {
			output.PrintError("Padding is off")
			return false
		}
	}

	msgBytes, ok := TCPReadAmount(conn, readSize)
	if !ok {
		return false
	}
	finalBuffer = append(finalBuffer, msgBytes...)

	if finalBuffer[0] != 'M' || finalBuffer[1] != '2' {
		output.PrintError("Missing m2 in response")
		return false
	}

	return ParseM2Message(finalBuffer, msg)
}
